#!/usr/bin/env python2
from csv import DictReader, DictWriter
from decimal import Decimal
from io import BytesIO
from sys import stdout
from zipfile import ZipFile

FIELDNAMES = (
    'Group No', 'Group Name', 'Name', 'Sub Name', 'Repeater Call Sign',
    'Gateway Call Sign', 'Frequency', 'Dup', 'Offset', 'Mode', 'TONE',
    'Repeater Tone', 'RPT1USE',
    'Position', 'Latitude', 'Longitude', 'UTC Offset')


def _drop_decimals(d):
    # Decimal.normalize gives 2E+1 for 20...
    d = str(d)
    if '.' in d:
        d = d.rstrip('0').rstrip('.')
    return d


def _supported(row):
    if 'Y' in (
            row['DMR'],
            # row['FUSION'],  # Fusion also operates Analog
            row['P25_PHASE_1'],
            row['P25_PHASE_2'],
            row['NXDN_DIGITAL'],
            row['ATV'],
            row['DATV'],
            ):
        # These are not Analog modes
        return False
    ifreq = Decimal(row['INPUT_FREQ'])
    if ifreq > 144 and ifreq < 148:
        # 2M
        return True
    if ifreq > 420 and ifreq < 450:
        # 70CM
        return True
    return False


def _offset(row):
    ifreq = Decimal(row['INPUT_FREQ'])
    ofreq = Decimal(row['OUTPUT_FREQ'])
    duplex = 'OFF'
    offset = Decimal(0)
    if ofreq < ifreq:
        duplex = 'DUP+'
        offset = ifreq - ofreq
    elif ofreq > ifreq:
        duplex = 'DUP-'
        offset = ofreq - ifreq
    return duplex, _drop_decimals(offset)


def _mode(row):
    mode = 'FM'
    if row['DSTAR_DV'] == 'Y':
        mode = 'DV'
    elif row['FM_WIDE'] == 'Y':
        mode = 'FM'
    elif row['FM_NARROW'] == 'Y':
        mode = 'FM-N'
    return mode


def _access(row):
    access = 'OFF'
    tone = '88.5Hz'
    tsql = '88.5Hz'
    if row['CTCSS_IN']:
        access = 'TONE'
        tone = '{:.1f}Hz'.format(Decimal(row['CTCSS_IN']))
        if row['CTCSS_OUT']:
            access = 'TSQL'
            tsql = '{:.1f}Hz'.format(Decimal(row['CTCSS_OUT']))
    # No DTCS possible!?
    return access, tone, tsql


def _name(row, pending=False):
    name = ' '.join((row['CALL'], row['CITY']))[:16]
    if pending:
        name = '[{}]'.format(name[:14])
    return name


def _call(row):
    call = row['CALL']
    if row['DSTAR_DV'] == 'N' and row['DSTAR_DD'] == 'N':
        return call, None
    ifreq = Decimal(row['INPUT_FREQ'])
    if ifreq > 144 and ifreq < 148:
        # 2M
        return '{:<7}C'.format(call), '{:<7}G'.format(call)
    if ifreq > 420 and ifreq < 450:
        # 70CM
        return '{:<7}B'.format(call), '{:<7}G'.format(call)


def _position(row):
    latitude = row['LATITUDE'] or '0'
    longitude = row['LONGITUDE'] or '-0'
    position = 'None'
    if latitude and longitude:
        position = 'Approximate'
    return position, latitude, longitude


def convert(z):
    wlist = []
    for n in z.namelist():
        if n.endswith('.csv'):
            if '-pending-' in n:
                pending = True
            else:
                pending = False
            with z.open(n) as c:
                # Remove the DATA_SPEC_VERSION header line from the .csv
                c.readline()
                d = DictReader(c)
                i = 0
                for row in d:
                    if not _supported(row):
                        continue
                    duplex, offset = _offset(row)
                    mode = _mode(row)
                    name = _name(row, pending)
                    call, gateway = _call(row)
                    access, tone, tsql = _access(row)
                    position, latitude, longitude = _position(row)
                    wlist.append({
                        'Group No': 7,
                        'Group Name': 'WWARA',
                        'Name': name,
                        'Sub Name': row['LOCALE'][:8],
                        'Repeater Call Sign': call,
                        'Gateway Call Sign': gateway,
                        'Frequency': _drop_decimals(row['OUTPUT_FREQ']),
                        'Dup': duplex,
                        'Offset': offset,
                        'Mode': mode,
                        'TONE': access,
                        'Repeater Tone': tone,  # No field for DTCS!?
                        'RPT1USE': 'YES',  # Something like "Don't Skip"?
                        'Position': position,
                        'Latitude': latitude,
                        'Longitude': longitude,
                        'UTC Offset': '-8:00',  # PST, but how is this useful!?
                        })
                    i += 1
    return sorted(wlist, key=lambda x: (x['Mode'], Decimal(x['Frequency'])))


def lambda_handler(event=None, context=None):
    import logging
    import boto3
    from os import environ
    from urlparse import urlparse

    s3 = boto3.client('s3')

    source = environ.get('SOURCE')
    src_parsed = urlparse(source)
    src_bucket = src_parsed.netloc
    src_key = src_parsed.path.lstrip('/')

    destination = environ.get('DESTINATION')
    dst_parsed = urlparse(destination)
    dst_bucket = dst_parsed.netloc
    dst_key = dst_parsed.path.lstrip('/')

    logging.info('Reading from %s', source)
    src = s3.get_object(Bucket=src_bucket, Key=src_key)
    data = src.get('Body').read()
    z = ZipFile(BytesIO(data))

    o = BytesIO()
    w = DictWriter(o, FIELDNAMES)
    w.writeheader()
    logging.info('Converting...')
    w.writerows(convert(z))

    logging.info('Writing to %s', destination)
    s3.put_object(Bucket=dst_bucket, Key=dst_key,
                  Body=o.getvalue(), ContentType='text/csv',
                  StorageClass='REDUCED_REDUNDANCY', ACL='public-read')
    o.close()


if __name__ == '__main__':
    import requests

    r = requests.get('https://www.wwara.org/DataBaseExtract.zip')
    # ZipFile requires a file-like object that supports seek
    f = BytesIO(r.content)
    r.close()
    z = ZipFile(f)

    w = DictWriter(stdout, FIELDNAMES)
    w.writeheader()

    w.writerows(convert(z))

    f.close()
